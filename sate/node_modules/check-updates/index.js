var Promise = require("bluebird");
var path = require("path");
var _ = require("lodash");
var obj2indent = require("obj2indent");
var chalk = require("chalk");
var ncu = require("npm-check-updates");

var noJsonError = function() {};
var circularError = function() {};
var maxDepthError = function() {};

var defaultOptions = {
    // Package managers to use
    npm: true,
    bower: true,
    // Max depth to check
    maxDepth: 10,
    // Return json instead of printing to console
    json: false,
    // Filter packages by name (or git repo in bower)
    npmFilter: /^@|\.\./,
    bowerFilter: /hp\.com|hpeswlab\.net/,
    // Include also devDependencies and optionalDependencies
    dev: true,
    optional: true,
    // Include also updates that are not needed, because dependency version is using range, that is satisfied by latest version
    satisfied: false
};

// init dependencies
var initManager = function(manager) {
    return ncu.initialize({packageManager: manager});
};

// load package.json or bower.json via require()
var getJson = {
    npm: function(package, maxDepth) {
        var packageList = package.split(path.sep + "node_modules");
        if (maxDepth && packageList.length > maxDepth) {
            throw new maxDepthError;
        } else if (_.contains(packageList.slice(0, -1), _.last(packageList))) {
            throw new circularError;
        }

        try {
            return require(path.join(process.cwd(), package, "package.json"));
        } catch (err) {
            // package.json not found, maybe dependency is installed higher in the tree because of npm optimalization, let's try to find it
            if (packageList.length <= 1) {
                // we are already at root folder, dependency is not installed at all
                throw new noJsonError;
            }
            // try parent node_modules folder
            var parentPackage = _.dropRight(packageList, 2).concat([_.last(packageList)]).join(path.sep + "node_modules");
            return getJson.npm(parentPackage, maxDepth);
        }
    },
    bower: function(package, maxDepth) {
        var packageList = package.split(path.sep);
        if (maxDepth && packageList.length > maxDepth) {
            throw new maxDepthError;
        }

        // packages can have circular dependencies
        if (_.contains(packageList.slice(0, -1), _.last(packageList))) {
            throw new circularError;
        }

        try {
            return require(path.join(process.cwd(), package ? "bower_components" : "", _.last(packageList), "bower.json"));
        } catch (err) {
            // dependency is not installed at all
            throw new noJsonError;
        }
    }
};

// Get formated dependencies from package.json or bower.json
var getDeps = {
    npm: function(managerJson, opts) {
        return _(ncu.getCurrentDependencies(managerJson, opts)).mapValues(this._transformMap).value();
    },
    bower: function(managerJson, opts) {
        var filter = opts.filter;
        delete opts.filter;
        return _(ncu.getCurrentDependencies(managerJson, opts)).pick(function(version, pkg) {
            return !_.isRegExp(filter) || filter.test(version) || filter.test(pkg);
        }).mapValues(this._transformMap).value();
    },
    _transformMap: function(version, pkg) {
        if (_.contains(version, "#")) {
            var versionParts = version.split("#");
            return {
                name: pkg,
                extName: versionParts.slice(0, -1).join("#"),
                version: _.last(versionParts)
            };
        }
        return {
            name: pkg,
            extName: pkg,
            version: version
        };
    }
};

// Get formatted package path, including node_modules in npm
var getPackageLocation = {
    npm: function(parentPackage, currentPackage) {
        return path.sep + path.join(parentPackage, "node_modules", currentPackage);
    },
    bower: function(parentPackage, currentPackage) {
        return (path.sep + path.join(parentPackage, currentPackage)).replace(path.sep + path.sep, path.sep);
    }
};

// Get updated packages
var getUpdates = function(manager, options) {
    var getUpdatesInternal = function(parentPackage, currentPackage) {
        var package = _.isString(parentPackage) && _.isString(currentPackage) ? getPackageLocation[manager](parentPackage, currentPackage) : "";

        try {
            var managerJson = getJson[manager](package, options.maxDepth);
        } catch (err) {
            return Promise.reject(err);
        }

        var deps = getDeps[manager](managerJson, {prod: true, filter: options[manager + "Filter"]});
        var devDeps = options.dev ? getDeps[manager](managerJson, {dev: true, filter: options[manager + "Filter"]}) : {};
        var optionalDeps = options.optional ? getDeps[manager](managerJson, {optional: true, filter: options[manager + "Filter"]}) : {};
        _.assign(deps, devDeps, optionalDeps);

        var pkgs = _.pluck(deps, "extName");
        var devPkgs = _.pluck(devDeps, "extName");
        var optionalPkgs = _.pluck(optionalDeps, "extName");

        var depsForNcu = _.zipObject(pkgs, _.pluck(deps, "version"));

        return ncu.getLatestVersions(pkgs, {}).then(function(latest) {
            var updatedDeps = ncu.upgradeDependencies(depsForNcu, latest);
            var updates = {};

            var promises = _.map(deps, function(pkg) {
                var result = updates[pkg.name] = {
                    name: pkg.name,
                    dev: _.includes(devPkgs, pkg.extName),
                    optional: _.includes(optionalPkgs, pkg.extName)
                };

                if (updatedDeps[pkg.extName]) {
                    var satisfied = ncu.isSatisfied(latest[pkg.extName], pkg.version);
                    if (!satisfied || options.satisfied) {
                        _.assign(result, {
                            update: true,
                            satisfied: satisfied,
                            dep: pkg.version,
                            latest: latest[pkg.extName],
                            updatedDep: updatedDeps[pkg.extName]
                        });
                    }
                }

                return getUpdatesInternal(package, pkg.name).then(function(childrenUpdates) {
                    if (_.size(childrenUpdates)) {
                        result.children = childrenUpdates;
                    }
                }).catch(function(err) {
                    if (err instanceof noJsonError) {
                        result.notInstalled = true;
                    } else if (err instanceof circularError) {
                        result.circular = true;
                    } else if (err instanceof maxDepthError) {
                        result.maxDepth = true;
                    }
                    return Promise.resolve();
                });
            });

            return Promise.all(promises).then(_.constant(updates));
        });
    };
    return getUpdatesInternal;
};

// Parse output to print with `obj2indent` package
var parseUpdates = function(updates) {
    updates = _(updates).map(function(pkg) {
        var showPkg = false, lineText = pkg.name;
        if (pkg.dev || pkg.optional) {
            lineText = chalk.bold.gray((pkg.dev ? "DEV" : "OPTIONAL") + "~") + lineText;
        }

        if (pkg.update) {
            lineText = chalk.bold[pkg.satisfied ? "yellow" : "red"](lineText) + "   " + chalk.yellow(pkg.dep) + " -> " + chalk.green(pkg.updatedDep);
            showPkg = true;
        }
        if (pkg.circular) {
            lineText += chalk.gray("   CIRCULAR DEPENDENCY");
            showPkg = true;
        }
        if (pkg.notInstalled) {
            lineText += chalk.magenta("   NOT INSTALLED");
            showPkg = true;
        }
        if (pkg.maxDepth) {
            lineText += chalk.gray("   MAXDEPTH REACHED");
            showPkg = true;
        }

        var children = parseUpdates(pkg.children || []);
        showPkg = showPkg || children.length;

        if (showPkg) {
            return {
                name: lineText,
                children: children
            };
        }
    }).filter().value();
    return updates;
};

// Format and print the output
var printUpdates = function(manager, updates) {
    console.log(chalk.bold.cyan("----- " + manager.toUpperCase() + " -----"));
    console.log(obj2indent(parseUpdates(updates), "      ") + "\n");
};

// Let's go through npm and bower dependencies and print updates to console
// One after another because dependency of `npm-check-updates` uses shared variables
module.exports = function(options) {
    options = _.assign({}, defaultOptions, options);
    var managers = [];
    options.npm && managers.push("npm");
    options.bower && managers.push("bower");

    return Promise.mapSeries(managers, function(manager) {
        return initManager(manager)
            .then(getUpdates(manager, options))
            .then(function(result) {
                return options.json ? _.zipObject(managers, result) : printUpdates(manager, result);
            })
            .catch(function(err) {
                if (options.json) {
                    throw err;
                } else if (err instanceof noJsonError) {
                    console.error("ERROR", manager, (manager === "npm" ? "package" : "bower") + ".json not found");
                } else {
                    console.error("ERROR", manager, err.message, err instanceof noJsonError);
                }
            });
    });
};
